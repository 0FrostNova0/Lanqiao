# 卡片

枚举

# 直线

枚举 

重点在于重复直线的判断

主要有两种方法：

1、対于当前直线，判断其两个点对于已记录直线是否符合Dis(Line.Point1,Point)+Dis(Line.point2,Point)==Length(Line)两个点均符合则为同一直线。

2、计算出当前直线的斜率k和截距b与已记录直线进行比较看k和b是否同时相同，是则为同一直线，这里注意一点与y轴平行的直线(即x1==x2)直接按21计算从而避免分母为0的情况

# 货物摆放

主要运用质因数分解

求出所有质因数及其次数可以得知有5个质因数，其中3的次数为3，其余为1，故结果为pow(3,5) * (5 * 4 / 2)=2430。

# 路径

预处理算出所有可能的两个点之间的道路距离然后运用Floyd或者Dijkstra算法求出答案

# 回路计数

最大公约数 状态压缩 动态规划

用21位二进制数表示初始状态，定义dp [ 1<<21-1 ] [ 21 ]数组其中第一维用来表示状态，即已经走过和没走过的，第二维表示终止点递推关系是dp[ state ] [ pos ] = dp[ state-pow(2,pos) ] [ i ]之和（i为0-21与pos互质的点）其中需要说明以1表示未经过，0表示已经经过。

# 砝码称重

动态规划

采用二维数组（也可采用一维数组），一维表示当前位置，一维表示重量，dp[0] [0]初始化为1，已知dp[i] [j]成立

可以得出dp[i+1] [j] ,dp[i+1] [j+weight[i]] ,dp[i+1] [fabs(j-weight[i])]三者成立，最后计算dp[n]中有多少不为0即答案。

# 异或数列

主要运用二进制相关思维和博弈论

重点是当number[1]^number[2]^number[3]^.......number[n]=0时出现平局。

以此为核心，记录二进制下所有数字的每一位为1的数字一共有多少，例如：5（101），6（110）中number[3]=2,number[2]=1,number[1]=1。当最高位为奇数时若为1则先手必胜，反之则判断所给n是否为奇数，若是则后手赢反之先手赢，若为偶数则最高位下降一位进行直到当前位置为偶数。

# 左孩子右兄弟

定义结构体，记录一个节点的父亲，孩子数量，一个点的最优位置是high[father]+T[father].sonnumber。最后遍历一遍找出最大值即可。

# 括号序列

动态规划及优化

dp数组第一维为位置，第二维为左括号比右括号多多少

首先由于"("和")"添加的区域相互独立，故方法计算上采用ways['(']*ways[')']。

其次在计算上可以将字符串逆序然后将左右括号互换，来实现简化代码。

在实现上，以添加左括号为例：

1、若当前扫描位置为左括号则易得f[i] [j]=f[i-1] [j-1]

2、若当前扫描位置为右括号则f[i] [j]=f[i-1] [0]+f[i-1] [1] +......f[i-1] [j]+f[i-1] [j+1] 分别表示在该括号前，上一个括号后添加左括号j个、j-1个、......1个、0个但若如此则时间复杂度为O（n^3）故将其优化为f[i] [j]=f[i-1] [j+1]+f[i] [j-1]。若j-1<0则视j-1为零。

# 分果果

不会

https://www.cnblogs.com/SOSCHINA/p/lanqiao_FenGuoGuo.html
