//第十二届蓝桥杯省赛（软件类真题)  C&C++大学B组
// 
// 
// 
//  A  空间
//结果：67108864









//  B  卡片  
#include <iostream>
#include<vector>
using namespace std;
int main() {
    vector<int> array(10, 2021);
    for (int i = 1; ; i++) 
    {
        int t = i;
        while (t) 
        {
            int a = t % 10;
            if (array[a] > 0) 
            {
                array[a]--;
            }
            else 
            {
                break;
            }
            t /= 10;
        }
        if (t)                                                                                          
        {
            cout << i-1 << endl;
            break;
        }
    }
    return 0;
}







//  C  直线   

#include<iostream>
#include<set>
using namespace std;
set<pair<double, double> > line_set;

int main()
{
    int x1, y1, x2, y2;
    for (x1 = 0; x1 < 20; x1++) {
        for (y1 = 0; y1 < 21; y1++) {
            for (x2 = 0; x2 < 20; x2++) {
                for (y2 = 0; y2 < 21; y2++) {
                    if (x1 != x2 && y1 != y2) {
                        double k = (y2 - y1) * 1.0 / (x2 - x1);
                        double b = (y2 * (x2 - x1) - (y2 - y1) * x2) * 1.0 / (x2 - x1);
                        pair<double, double> newline;
                        newline.first = k;
                        newline.second = b;
                        line_set.insert(newline);
                    }
                }
            }
        }
    }
    printf("%d", line_set.size() + 20 + 21);
    return 0;
}
//40257












//     D     货物摆放
#include<iostream>
#include<set>
#include<map>
#include<iomanip>
#include<vector>
#include<cmath>
using namespace std;
typedef long long ll;
int main()
{
    ll n = 2021041820210418;
    ll en1 = sqrt(n);
    ll ans = 0;
    for (ll a = 1; a <= en1; a++) {
        if (n % a == 0) {
            ll nn = n / a;
            ll en2 = sqrt(nn);
            for (ll b = 1; b <= en2; b++) {
                if (nn % b == 0) {
                    ll c = nn / b;
                    if (c >= b && b >= a) {
                        set<int> s;
                        s.insert(a);
                        s.insert(b);
                        s.insert(c);

                        if (s.size() == 1)ans++;
                        else if (s.size() == 2)ans += 3;
                        else if (s.size() == 3)ans += 6;
                    }
                }
            }
        }
    }
    printf("%lld", ans);
    return 0;
}












//     E     路径
#include<iostream>
#include<set>
#include<map>
#include<iomanip>
#include<vector>
#include<cmath>
using namespace std;
long long gcd(long long a, long long b) { 
    int t;
    if (a < b) {
        t = b;
        b = a;
        a = t;
    }
    while (b) {
        t = a % b;
        a = b;
        b = t;
    }
    return a;
}
int main() {
    vector<vector<long long>> array(2022, vector<long long>(2022, INT_MAX));                   
    for (long long i = 1; i <= 2021; i++) { 
        for (long long j = i + 1; j <= i + 21; j++) {
            array[i][j] = i * j / gcd(i, j);
        }
    }
    for (long long i = 1; i <= 2021; i++) {
        for (long long j = i + 1; j <= 2021; j++) {
            for (long long k = i + 1; k < j; k++) { 
                array[i][j] = fmin(array[i][j], (array[i][k] + array[k][j]));
            }
        }
    }
    cout << array[1][2021] << endl;
    return 0;
}














//   F    时间显示
#include<iostream>
#include<set>
#include<map>
#include<iomanip>
#include<vector>
#include<cmath>
using namespace std;
typedef long long ll;
int main()
{
    ll n;
    scanf("%lld", &n);
    n /= 1000;
    n %= (24 * 60 * 60);
    int ss = n % 60;
    n /= 60;
    int mm = n % 60;
    n /= 60;
    int hh = n % 60;
    n /= 60;
    printf("%02d:%02d:%02d", hh, mm, ss);
    return 0;
}












//     G    砝码称重
#include<iostream>
#include<set>
#include<map>
#include<iomanip>
#include<vector>
#include<cmath>
using namespace std;
const int N = 110, M = 200010;
int main() {
    int n;
    int sum = 0;  
    vector<int>w(N);
    vector<vector<bool> > dp(N, vector<bool>(M, false)); 
    scanf("%d", &n); 
    for (int i = 1; i <= n; i++) {
        scanf("%d", &w[i]);
        sum += w[i];
    }
    dp[0][0] = true;
    for (int i = 1; i <= n; i++) { 
        for (int j = 0; j <= sum; j++) { 
            dp[i][j] = dp[i - 1][j] || dp[i - 1][fabs(j - w[i])] || dp[i - 1][j + w[i]];
        }
    }
    long long ans = 0;
    for (int i = 1; i <= sum; i++) {
        if (dp[n][i]) {  
            ans++;
        }
    }
    cout << ans << endl;
    return 0;
}





//     H   杨辉三角形
#include<iostream>
#include<set>
#include<map>
#include<iomanip>
#include<vector>
#include<cmath>
using namespace std;
int n;
long long C(int a, int b) { 
    long long res = 1;
    for (int i = a, j = 1; j <= b; i--, j++) {
        res = res * i / j;
        if (res > n) {
            return res;
        }
    }
    return res;
}

bool check(int k) {
    long long l = k * 2;
    long long r = fmax(l, n);
    while (l < r) {
        long long mid = l + r >> 1;
        if (C(mid, k) >= n) {
            r = mid;
        }
        else {
            l = mid + 1;
        }
    }
    if (C(r, k) != n) {
        return false;
    }
    cout << r * (r + 1) / 2 + k + 1 << endl;
    return true;
}

int main() {
    cin >> n;
    for (int k = 16; ; k--) { 
        if (check(k)) { 
            break;
        }
    }
    return 0;
}










//      I      双向排序
#include<iostream>
#include<set>
#include<map>
#include<iomanip>
#include<vector>
#include<cmath>
using namespace std;
const int N = 100010;
vector<pair<int, int> > act(N); 
vector<int> ans(N);
int main() {
    int n, m;
    int count = 0;
    cin >> n >> m;
    while (m--) {
        int p, q;
        cin >> p >> q;
        if (!p) {
            while (count && act[count].first == 0) { 
                q = max(q, act[count--].second);
            }
            while (count >= 2 && act[count - 1].second <= q) {
                count -= 2;
            }
            act[++count] = { 0, q };
        }
        else if (count) {
            while (count && act[count].first) { 
                q = min(q, act[count--].second);
            }
            while (count >= 2 && act[count - 1].second >= q) {
                count -= 2;
            }
            act[++count] = { 1, q };
        }
    }
    int left = 1;
    int right = n;
    int k = n;
    for (int i = 1; i <= count; i++) { 
        if (act[i].first == 0) {
            while (right > act[i].second && left < right + 1) {
                ans[right--] = k--;
            }
        }
        else {
            while (left < act[i].second && left < right + 1) {
                ans[left++] = k--;
            }
        }
        if (left > right) {
            break;
        }
    }
    if (count % 2) { 
        while (left < right + 1) {
            ans[left++] = k--;
        }
    }
    else {
        while (left < right + 1) {
            ans[right--] = k--;
        }
    }
    for (int i = 1; i <= n; i++) {
        cout << ans[i] << " ";
    }
    return 0;
}









//        J      括号排序
#include<iostream>
#include<set>
#include<map>
#include<iomanip>
#include<vector>
#include<cmath>
using namespace std;
const int N = 5010;
const int mod = 1e9 + 7;
int n;
char str[N];
long long dp[N][N];

long long compute() {
    memset(dp, 0, sizeof(dp));
    dp[0][0] = 1;
    for (int i = 1; i <= n; i++) {
        if (str[i] == '(') {
            for (int j = 1; j <= n; j++) {
                dp[i][j] = dp[i - 1][j - 1];
            }
        }
        else {
            dp[i][0] = (dp[i - 1][0] + dp[i - 1][1]) % mod;
            for (int j = 1; j <= n; j++) {
                dp[i][j] = (dp[i - 1][j + 1] + dp[i][j - 1]) % mod;
            }
        }
    }
    for (int i = 0; i <= n; i++) {
        if (dp[n][i]) {
            return dp[n][i];
        }
    }
    return -1;
}

int main() {
    scanf("%s", str + 1); 
    n = strlen(str + 1); 
    long long l = compute();
    reverse(str + 1, str + n + 1); 
    for (int i = 1; i <= n; i++) { 
        if (str[i] == '(') {
            str[i] = ')';
        }
        else {
            str[i] = '(';
        }
    }
    long long r = compute();
    cout << l * r % mod << endl;
    return 0;
}















//2020第十一届蓝桥杯软件类省赛第二场C/C++ 大学 C 组
//     A     约数个数
#include <iostream>
using namespace std;
int main() {
    int ans = 0;
    for (int i = 1; i <= 78120; ++i) {
        if (78120 % i == 0) {
            ans++;
        }
    }
    cout << ans;
    return 0;
}
//96







//     B     门派制作
#include <iostream>
#include <stdlib.h>
#include <string.h>
using namespace std;
int main() {
    int ans = 0;
    for (int i = 1; i <= 2020; ++i) {
        char s[10];
        itoa(i, s, 10);
        for (int j = 0; j < strlen(s); ++j) {
            if (s[j] == '2') {
                ans++;
            }
        }
    }
    cout << ans;
    return 0;
}
//624











//     C     跑步锻炼
#include <iostream>
using namespace std;
int main() {
    int calendar[] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };
    int week = 6;
    int mondays = 0;
    int first_of_month = 0;
    int mondays_and_first_of_month = 0;
    int total_days = 0;

    for (int year = 2000; year <= 2020; ++year) {
        for (int month = 1; month <= 12; ++month) {
            for (int day = 1; day <= calendar[month]; ++day) {
    
                if (week == 1) mondays++;
                if (day == 1) first_of_month++;
                if (week == 1 && day == 1) mondays_and_first_of_month++;
    
                total_days++;
                week = week % 7 + 1;
    
                if ((year % 400 == 0 || year % 4 == 0 && year % 100 != 0) && month == 2 && day == 28) {
                    total_days++;
                    week = week % 7 + 1;//
                    if (week == 1) mondays++;
                }
                if (year == 2020 && month == 10 && day == 1) {
                    int ans = total_days + mondays + first_of_month - mondays_and_first_of_month;
                    cout << ans;
                    return 0;
                }
            }
        }
    }
}
//8879













//     D     平面分割
//1391







//     E     蛇形填数
#include <iostream>
using namespace std;
int main() {
    int a[60][60] = { 0 };
    int t = 1;
    int n = 20;
    for (int i = 0; i < 60; ++i) {
        if (i % 2 == 0) {
            for (int j = 0; j <= i; ++j) {
                a[i][j] = t++;
            }
        }
        else {
            for (int j = i; j >= 0; --j) {
                a[i][j] = t++;
            }
        }
    }
    cout << a[(n - 1) * 2][n - 1];
    return 0;
}
//761





//     F     成绩统计
#include <iostream>
#include <stdio.h>
#include <vector>
using namespace std;
int main() {
    int n;
    vector<int> a;
    int sixty = 0, eighty_five = 0;
    cin >> n;
    for (int i = 0; i < n; ++i) {
        int t;
        cin >> t;
        if (t >= 60) sixty++;
        if (t >= 85) eighty_five++;
        a.push_back(t);
    }
    double pass_rate = sixty * 1.0 / a.size() * 100;
    double excellence_rate = eighty_five * 1.0 / a.size() * 100;
    printf("%.f%%\n%.f%%", pass_rate, excellence_rate);
    return 0;
}












//     G     单词分析
#include <iostream>
using namespace std;
int main() {
    string a;
    cin >> a;
    int s[26] = { 0 };
    for (int i = 0; i < a.length(); ++i) {
        s[a[i] - 97]++;
    }
    int max = 0;
    char max_char;
    for (int i = 25; i >= 0; --i) {
        if (s[i] >= max) {
            max = s[i];
            max_char = i + 97;
        }
    }
    cout << max_char << endl << max;
    return 0;
}















//     H     数学三角形
#include <iostream>
#include <math.h>
using namespace std;
struct node {
    int value, right, left;
};
int main() {
    node a[105][105] = { 0 };
    int n;
    cin >> n;

    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= i; ++j) {
            cin >> a[i][j].value;
        }
    }
    for (int i = 2; i <= n; ++i) {
        for (int j = 1; j <= i; ++j) {
            if (a[i - 1][j - 1].value > a[i - 1][j].value) {
                a[i][j].value += a[i - 1][j - 1].value;
                a[i][j].right += a[i - 1][j - 1].right + 1;
                a[i][j].left += a[i - 1][j - 1].left;
            }
            else {
                a[i][j].value += a[i - 1][j].value;
                a[i][j].right += a[i - 1][j].right;
                a[i][j].left += a[i - 1][j].left + 1;
            }
        }
    
    }
    
    int max = 0;
    for (int i = 0; i < n; ++i) {
        if (a[n][i].value > max && abs(a[n][i].left - a[n][i].right) <= 1) {
            max = a[n][i].value;
        }
    }
    cout << max;
    return 0;
}























//     I     作物杂交
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>
using namespace std;
const int N = 2010, M = 100010;
int n, m, k, t;
int d[N]; 
int g[N]; 
bool st[N];
struct Edge
{
    int a, b;
}e[M];
int h[N], ne[M], idx;

void add(int c, int a, int b)
{
    e[idx].a = a; e[idx].b = b; ne[idx] = h[c]; h[c] = idx++;
}

int dfs(int u)
{
    if (st[u]) return g[u];

    for (int i = h[u]; ~i; i = ne[i])
    {
        Edge t = e[i];
        g[u] = min(g[u], max(d[t.a], d[t.b]) + max(dfs(t.a), dfs(t.b)));
    }
    st[u] = true;
    return g[u];
}
int main()
{
    scanf("%d%d%d%d", &n, &m, &k, &t);

    for (int i = 1; i <= n; i++) scanf("%d", &d[i]); 
    
    memset(g, 0x3f, sizeof g);
    for (int i = 0; i < m; i++)
    {
        int x;
        scanf("%d", &x);
        st[x] = true;
        g[x] = 0;
    }
    
    memset(h, -1, sizeof h); 
    for (int i = 0; i < k; i++)
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(c, a, b);
    }
    
    dfs(t);
    
    printf("%d", g[t]);
    return 0;
}
















//     J     字串分值和
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
typedef long long ll;
string str;
ll last[26];
ll ans = 0;
int main() {
    for (int i = 0; i < 26; i++)
        last[i] = -1;
    cin >> str;
    ll len = str.size();
    for (ll i = 0; i < len; i++) {
        ans += (i - last[str[i] - 'a']) * (len - i);
        last[str[i] - 'a'] = i;
    }
    cout << ans << endl;
    return 0;
}
























//第九届蓝桥杯大赛个人赛决赛（软件类）C  大学B组
//     A    换零钞
#include<iostream>
using namespace std;
const int N = 200;
int res = 1e9;
int main() {
    for (int i = 1; i <= 200 / 21; i++) {
        int j = (200 - 21 * i);
        if (j % 5 == 0) {
            res = min(res, 11 * i + j / 5);
        }
    }
    cout << res;
    return 0;
}











//     B    激光样式
#include<iostream>
using namespace std;
const int N = 40;
int f[N][2];
int main() {
    f[0][0] = 1;
    for (int i = 1; i <= 30; i++) {
        f[i][0] = f[i - 1][0] + f[i - 1][1];
        f[i][1] = f[i - 1][0];
    }
    cout << f[30][0] + f[30][1];
    return 0;
}








//     C    格雷码
//a ^ ((a& (-a)) << 1)












//     D    调手表
#include<iostream>
#include<queue>
#include<cstring>
#define mm(a,x) memset(a,x,sizeof a)
#define inf 0x3f3f3f3f
using namespace std;
const int N = 1e5 + 10;
int n, k;
int dist[N];
int res;
void bfs(int u) {
    queue<int > q;
    mm(dist, inf);
    q.push(u);
    dist[u] = 0;
    while (q.size()) {
        int t = q.front();
        q.pop();
        int p = (t + 1) % n;
        if (dist[p] == inf) {
            dist[p] = dist[t] + 1;
            q.push(p);
        }
        p = (t + k) % n;
        if (dist[p] == inf) {
            dist[p] = dist[t] + 1; 
            q.push(p);
        }
    }
}
int main() {
    cin >> n >> k;
    bfs(0);
    for (int i = 0; i <= n - 1; i++) {
        res = max(res, dist[i]);
    }
    cout << res;
    return 0;
}











//     E    搭积木
#include<iostream>
#include<set>
#include<map>
#include<iomanip>
#include<vector>
#include<cmath>
using namespace std;
#define MOD 1000000007
typedef long long LL;
const int maxn = 110;
LL dp[maxn][maxn];
int check[maxn][maxn];
int main() {
    int n, m;
    char str[maxn];
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) {
        scanf("%s", str + 1);
        for (int j = 1; j <= m; j++) {
            check[i][j] = check[i][j - 1];
            if (str[j] == 'X') {
                check[i][j]++;
            }
        }
    }
    LL ans = 1;
    for (int i = 1; i <= m; i++) {
        for (int j = m; j >= i; j--) {
            if (check[n][j] - check[n][i - 1] == 0) {
                ans++;
                dp[i][j] = dp[i][j + 1] + dp[i - 1][j] - dp[i - 1][j + 1] + 1;
            }
        }
    }
    for (int t = n - 1; t > 0; t--) {
        for (int i = 1; i <= m; i++) {
            for (int j = m; j >= i; j--) {
                if (check[t][j] - check[t][i - 1] == 0) {
                    ans = (ans + dp[i][j]) % MOD;
                    dp[i][j] = (dp[i][j] + dp[i - 1][j] + dp[i][j + 1] - dp[i - 1][j + 1]) % MOD;
                }
                else {
                    dp[i][j] = 0;
                }
            }
        }
    }
    printf("%lld\n", ans);
    return 0;
}
















//     F    矩阵求和

#include<iostream>
#include<set>
#include<map>
#include<iomanip>
#include<vector>
#include<cmath>
using namespace std;
#define ll long long
const ll N = 1e7 + 5;
const ll p = 1e9 + 7;
ll phi[N], s[N], cnt, vis[N], prim[N];
void init() {
    phi[1] = 1;
    for (int i = 2; i <= N; i++) {
        if (!vis[i]) {
            phi[i] = i - 1;
            prim[++cnt] = i;
        }
        for (int j = 1; j <= cnt; j++) {
            int tp = prim[j];
            if (i * tp > N) break;
            vis[i * tp] = true;
            if (i % tp == 0) {
                phi[i * tp] = phi[i] * tp; break;
            }
            else phi[i * tp] = phi[i] * phi[tp];
        }
    }
    s[1] = phi[1];
    for (int i = 2; i < N; i++)
        s[i] = s[i - 1] + 2 * phi[i];
}
int main() {
    int n;
    init();
    while (cin >> n) {
        ll ans = 0;
        for (ll i = 1; i <= n; i++)
            ans = (ans + s[n / i] * i % p * i % p) % p;
        cout << ans << endl;
    }
    return 0;
}