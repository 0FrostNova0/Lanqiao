# A 门牌号

题意：统计 [1,2020][1,2020] 所有整数中，数码 22 出现的次数

分析：直接暴力枚举即可：

```cpp
inline int f(int n){
      int ans=0;
      while(n) ans+=(n%10==2),n/=10;
      return ans;
}
...
int ans=0;
for(int i=1;i<=2020;i++) ans+=f(i);
```

输出为 624624

------

# B 既约分数

题意：对于满足 a,b∈Z，aba,b∈Z，ab 为最简分数的分数称为既约分数，求 1≤a,b≤20201≤a,b≤2020 的既约分数个数

分析：暴力枚举 a,ba,b ，用 gcd 判是否互质

```cpp
int ans=0;
for(int a=1;a<=2020;a++)
      for(int b=1;b<=2020;b++)
            ans+=(__gcd(i,j)==1);
```

输出为 24812152481215

------

# C 蛇形矩阵

分析：考虑令 fnfn 为第 nn 行 nn 列的值

不难看出，fnfn 转移至 fn+1fn+1 需要自己所在斜线走一半+下一条斜线走完+fn+1fn+1 所在斜线走一半

根据各斜线的长度，不难列出转移方程 fn+1=fn+n−1+2n+n+1=fn+4nfn+1=fn+n−1+2n+n+1=fn+4n ，可解出 fn=4∑i=1n−1i+f1=2n(n−1)+1fn=4∑i=1n−1i+f1=2n(n−1)+1

代入 n=20n=20 得到 f20=761f20=761

------

# D 七段码

题意：求多少种不同的七段码表示方法，各个亮起的灯管互相连接，且至少有一个灯管亮起

分析：用数组储存灯管间的连接情况，枚举 2727 种情况，用 bfs 检查是否满足，统计答案即可

```cpp
#include<bits/stdc++.h>
using namespace std;
bool connect[7][7]={
    {0,1,0,0,0,1,0},
    {1,0,1,0,0,0,1},
    {0,1,0,1,0,0,1},
    {0,0,1,0,1,0,0},
    {0,0,0,1,0,1,1},
    {1,0,0,0,1,0,1},
    {0,1,1,0,1,1,0}
};
inline int isconnect(int S){
    int que[16],Head=0,Tail=0,NS=0;
    bool vis[16]={0};
    for(int i=0;i<7;i++) if( (S>>i)&1 ){
        que[++Tail]=i;
        vis[i]=1;
        break;
    }
    while(Head<Tail){
        int now=que[++Head];
        NS|=1<<now;
        for(int i=0;i<7;i++)
            if( ((S>>i)&1)&&connect[now][i]&&!vis[i] ){
                que[++Tail]=i;
                vis[i]=1;
            }
    }
    return NS==S;
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int Ans=0;
    for(int i=1;!(i>>7);i++) Ans+=isconnect(i);
    cout<<Ans;
    cout.flush();
    return 0;
}
```

输出为 8080

------

# E 直线与圆

题意：用 2020 条直线与 2020 个圆，求最多能将平面分为几个部分

分析：任意线（包括直线与曲线）之间，不交于同一点，则能将平面分为尽可能多的部分

根据欧拉定理 V−E+F−T=1,T=0V−E+F−T=1,T=0 ，求解出 F=1+E−VF=1+E−V ，只需求解出点数 VV 与边数 VV 即可求解

根据我们的分析，任意两直线即可有一交点，个数为 (202)(220) ；任意两圆之间有两个交点，个数为 2⋅(202)2⋅(220) ；任意圆与直线之间有两个交点，个数为 20×20×220×20×2

故 V=(202)+2⋅(202)+20×20×2=1370V=(220)+2⋅(220)+20×20×2=1370

同样根据我们的分析，一条直线被剩余的 1919 条直线各交于一点，被 2020 个圆各交于两点，故线上有 19+20×2=5919+20×2=59 个点，一条直线被分为 6060 条边；一个圆被剩余的 1919 个圆、 2020 条直线各交于两点，共 (19+20)×2=78(19+20)×2=78 个点，一个圆被分为 7878 条边

故 E=60×20+78×20=2760E=60×20+78×20=2760

因此得到答案： F=1+2760−1370=1391F=1+2760−1370=1391

------

# F 成绩分析

题意：给出 nn 个学生的成绩，求最高分、最低分与平均值

分析：直接在输入的时候储存最大值、最小值和分数和，最后分数和除去人数得到平均分

------

# G 回文年份

题意：输入一个日期，输出严格后于日期的第一个 ABCDDCBA 型日期，和第一个 ABABBABA 型日期。保证有解。

分析：第一种日期，直接枚举对应月份的对应日期，进行翻转，储存好 366366 个日期后排序，查找第一个比输入大的即可（数据量太小，懒得写二分了）。第二种日期，由于月份和日期相同，直接枚举月份，进行翻转，储存好 1212 个日期后和第一个储存方法相同。

# H 子串序列

题意：求一个字符串 SS 的所有子串中，每个子串出现仅一次的字符个数和

分析：对于每一个字符单独考虑：对于第 ii 个字符 cc ，设其前面第一个与之相同的字符出现的位置为 preiprei （没有则为 00），后面第一个为 nxtinxti （没有则为 n+1n+1）

则对于满足 l∈(prei,i],r∈[i,nxti)l∈(prei,i],r∈[i,nxti) 的所有区间 [l,r][l,r] ，仅出现一个字符 cc ，故对每个区间都产生 11 的贡献，总贡献即为 (i−prei)⋅(nxti−i)(i−prei)⋅(nxti−i) ，每个统计起来即可